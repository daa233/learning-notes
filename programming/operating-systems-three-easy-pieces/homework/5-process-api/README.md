## 问题

**1．编写一个调用 `fork()` 的程序。在调用 `fork()` 之前，让主进程访问一个变量（例如`x`）并将其值设置为某个值（例如100）。子进程中的变量有什么值？当子进程和父进程都改变x的值时，变量会发生什么？**

解答：见 [q1.c](q1.c)。在调用 `fork()` 前设置 `a` 为 1，子进程的中 `a` 也为1；当子进程和父进程都改变 `b` 的值时，二者互不影响，各自进程中 `b` 变量的值分别被改动。

**2．编写一个打开文件的程序（使用 `open()` 系统调用），然后调用 `fork()` 创建一个新进程。子进程和父进程都可以访问 `open()` 返回的文件描述符吗？当它们并发（即同时）写入文件时，会发生什么？**

解答：见 [q2.c](q2.c)。子进程和父进程都可以访问 `open()` 返回的文件描述符。并发写入时，子进程和父进程都会写入到同一个文件里。

**3．使用 `fork()` 编写另一个程序。子进程应打印“hello”，父进程应打印“goodbye”。你应该尝试确保子进程始终先打印。你能否不在父进程调用 `wait()` 而做到这一点呢？**

解答：

**4．编写一个调用 `fork()` 的程序，然后调用某种形式的 `exec()` 来运行程序 `/bin/ls`。看看是否可以尝试 `exec()` 的所有变体，包括 `execl()`、`execle()`、`execlp()`、`execv()`、`execvp()` 和 `execvP()`。为什么同样的基本调用会有这么多变种？**

解答：见 [q4.c](q4.c)。不同调用接口不一样，满足不同的需求。

**5．现在编写一个程序，在父进程中使用 `wait()`，等待子进程完成。`wait()` 返回什么？如果你在子进程中使用 `wait()` 会发生什么？**

解答：见 [q5.c](q5.c)。`wait()` 返回等待的子进程的 id。在子进程中使用 `wait()`，没有等待的子进程，返回 -1。

**6．对前一个程序稍作修改，这次使用 `waitpid()` 而不是 `wait()`。什么时候 `waitpid()` 会有用？**

解答：见 [q6.c](q6.c)。和 `wait()` 相比，`waitpid()` 多了一些参数：

```
pid_t
wait(int *stat_loc);

pid_t
waitpid(pid_t pid, int *stat_loc, int options);
```

参考[这里](http://poincare.matf.bg.ac.rs/~ivana/courses/ps/sistemi_knjige/pomocno/apue/APUE/0201433079/ch08lev1sec6.html)，`wait()` 和 `waitpid()` 的主要区别是：
* `wait()` 会阻塞主进程，直到有某个子进程终止了；`waitpid()` 有一些参数控制来避免阻塞。
* `waitpid()` 可以指定具体等待哪个进程，默认不等待子进程终止，可以通过参数控制具体等待的事件。

**7．编写一个创建子进程的程序，然后在子进程中关闭标准输出（`STDOUT_FILENO`）。如果子进程在关闭描述符后调用`printf()` 打印输出，会发生什么？**

解答：见 [q7.c](q7.c)。子进程在关闭描述符后调用`printf()` 打印输出，终端没有输出，主进程不受影响。

**8．编写一个程序，创建两个子进程，并使用 `pipe()` 系统调用，将一个子进程的标准输出连接到另一个子进程的标准输入。**


